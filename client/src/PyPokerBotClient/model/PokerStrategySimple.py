"""
This module contains a very simple strategy class for the PyPokerBot. Strategy classes
are special classes that receives as input the dictionary generated by the PokerTableScanner
class and then generate a decision for that situation and a command that needs to be send
to the Poker Client Software (usually simulating a mouse click).
"""
from PyPokerBotClient.model.PokerStrategy import PokerStrategy
from PyPokerBotClient.model.PokerTableScanner import has_command_to_execute


class PokerStrategySimple(PokerStrategy):
    """
    The PokerStrategySimple Class encapsulates a very simple strategy for the PyPokerBot,
    which is a decision tree based both on the current position of the player on the
    table and its calculated equity (Probabily of having the best hand). There are many
    strategies available and being researched as a field of Computer AI, but this is the
    simplest imaginable.
    """
    def __init__(self):
        """
        Default Constructor, which calls the super class constructor as well...
        """
        PokerStrategy.__init__(self)

    def generate_command(self, analisys):
        """
        This method generates a command (which is a index of a button on the poker
        client software), where we need to send a click. It analisys the text of the
        decision and the text of the commands and then return a dictionary with a single
        key: to_execute populated with the index to execute.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: a dictionary containing the "to_execute" key filled with the index of the
            command to send
        """
        ret = {'to_execute': 0}

        if not has_command_to_execute(analisys):
            return ret
        number_of_commands = len(analisys['commands'])

        if analisys['decision']['decision'] == 'FOLD OR CHECK':
            for x in range(number_of_commands):
                if 'CHECK' == analisys['commands'][x][0]:
                    ret['to_execute'] = x + 1
                    return ret
            for x in range(number_of_commands):
                if 'FOLD' == analisys['commands'][x][0]:
                    ret['to_execute'] = x + 1
                    return ret

        if analisys['decision']['decision'] == 'RAISE':
            for x in range(number_of_commands):
                if 'RAISE' == analisys['commands'][x][0] or 'BET' == analisys['commands'][x][0]:
                    ret['to_execute'] = x + 1
                    return ret
            for x in range(number_of_commands):
                if 'CALL' == analisys['commands'][x][0]:
                    ret['to_execute'] = x + 1
                    return ret
            for x in range(number_of_commands):
                if 'CHECK' == analisys['commands'][x][0]:
                    ret['to_execute'] = x + 1
                    return ret

        if analisys['decision']['decision'] == 'CALL':
            for x in range(number_of_commands):
                if 'CALL' in analisys['commands'][x][0]:
                    ret['to_execute'] = x + 1
                    return ret
            for x in range(number_of_commands):
                if 'CHECK' in analisys['commands'][x][0]:
                    ret['to_execute'] = x + 1
                    return ret

        return ret

    def get_current_call_value(self, analisys):
        """
        This method returns the current value (money amount) necessary to call anothers
        player bet, as described on the analisys dictionary passed as parameter

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: A number indicating the money amount to call another player.
        """
        call_button = [x for x in analisys['commands'] if x[0] == 'CALL']
        if len(call_button) > 0:
            return call_button[0][1]
        else:
            return 0

    def is_check_button_available(self, analisys):
        """
        Return if the CHECK Button is available on the Poker Client UI.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: True or False
        """
        return len([x for x in analisys['commands'] if x[0] == 'CHECK']) > 0

    def position_button(self, analisys):
        """
        Return if the player is on the button or not.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: True or False
        """
        return analisys['hero']['position'] == 'BUTTON' or analisys['hero']['position'] == 'LP'

    def position_out_position(self, analisys):
        """
        Return if the player is out of position or not.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: True or False
        """
        return not ((analisys['hero']['position'] == 'BUTTON') or (analisys['hero']['position'] == 'LP'))

    def position_bb_check(self, analisys):
        """
        This method checks if the player is on the BigBlind position and the check button is
        available.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: True or False
        """
        return analisys['hero']['position'] == 'BB' and self.is_check_button_available(analisys)

    def position_button_check(self, analisys):
        """
        This method checks if the player is on the button position and the check button is
        available.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: True or False
        """
        return self.position_button(analisys) and self.is_check_button_available(analisys)

    def generate_pre_decision(self, analisys):
        """
        This method implements a very simple decision to be made based on a decision tree using
        the analisys dictionary returned by the PokerTableScanner instance

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: A tuple containing the decision: RAISE OR CALL, CALL OR FOLD, FOLD OR CHECK
            and the amount in big blinds to raise or call.
        """
        try:
            phase = analisys['hand_analisys']['hand_phase']
            hand_equity = analisys['hand_analisys']['result'][0][1]

            if phase == 'PREFLOP':
                if self.position_button(analisys):
                    if hand_equity > 0.77:
                        return ('RAISE OR CALL', 20)
                    if hand_equity > 0.72:
                        return ('RAISE OR CALL', 10)
                    if hand_equity > 0.60:
                        return ('RAISE OR CALL', 5)
                if self.position_out_position(analisys):
                    if hand_equity > 0.77:
                        return ('RAISE OR CALL', 20)
                    if hand_equity > 0.72:
                        return ('RAISE OR CALL', 5)
                if self.position_bb_check(analisys):
                    if hand_equity > 0.77:
                        return ('RAISE OR CALL', 20)
                    if hand_equity > 0.72:
                        return ('RAISE OR CALL', 20)
                    if hand_equity > 0.60:
                        return ('RAISE OR CALL', 5)
            if phase == 'FLOP3':
                if self.position_button(analisys):
                    if hand_equity > 0.77:
                        return ('RAISE OR CALL', 20)
                    if hand_equity > 0.72:
                        return ('RAISE OR CALL', 10)
                    if hand_equity > 0.60:
                        return ('CALL OR FOLD', 5)
                if self.position_button_check(analisys):
                    if hand_equity > 0.77:
                        return ('RAISE OR CALL', 20)
                    if hand_equity > 0.72:
                        return ('RAISE OR CALL', 10)
                    if hand_equity > 0.60:
                        return ('RAISE OR CALL', 5)
                    return ('RAISE OR CALL', 5)
                if self.position_out_position(analisys):
                    if hand_equity > 0.77:
                        return ('RAISE OR CALL', 20)
                    if hand_equity > 0.72:
                        return ('RAISE OR CALL', 10)
                    if hand_equity > 0.60:
                        return ('CALL OR FOLD', 5)
            if phase == 'FLOP4':
                if self.position_button(analisys):
                    if hand_equity > 0.77:
                        return ('RAISE OR CALL', 40)
                    if hand_equity > 0.72:
                        return ('RAISE OR CALL', 20)
                    if hand_equity > 0.60:
                        return ('CALL OR FOLD', 10)
                if self.position_button_check(analisys):
                    if hand_equity > 0.77:
                        return ('RAISE OR CALL', 40)
                    if hand_equity > 0.72:
                        return ('RAISE OR CALL', 20)
                    if hand_equity > 0.60:
                        return ('RAISE OR CALL', 10)
                    return ('RAISE OR CALL', 10)
                if self.position_out_position(analisys):
                    if hand_equity > 0.77:
                        return ('RAISE OR CALL', 40)
                    if hand_equity > 0.72:
                        return ('RAISE OR CALL', 20)
                    if hand_equity > 0.60:
                        return ('CALL OR FOLD', 10)
            if phase == 'FLOP5':
                if self.position_button(analisys):
                    if hand_equity > 0.77:
                        return ('RAISE OR CALL', 40)
                    if hand_equity > 0.72:
                        return ('RAISE OR CALL', 20)
                    if hand_equity > 0.60:
                        return ('CALL OR FOLD', 10)
                if self.position_button_check(analisys):
                    if hand_equity > 0.77:
                        return ('RAISE OR CALL', 40)
                    if hand_equity > 0.72:
                        return ('RAISE OR CALL', 20)
                    if hand_equity > 0.60:
                        return ('RAISE OR CALL', 10)
                    return ('RAISE OR CALL', 10)
                if self.position_out_position(analisys):
                    if hand_equity > 0.77:
                        return ('RAISE OR CALL', 40)
                    if hand_equity > 0.72:
                        return ('RAISE OR CALL', 20)
                    if hand_equity > 0.60:
                        return ('CALL OR FOLD', 10)
        except:
            pass
        return ('FOLD OR CHECK', 0)

    def generate_decision(self, analisys):
        """
        This method implements a very simple decision to be made based on a decision tree using
        the analisys dictionary returned by the PokerTableScanner instance

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: A tuple containing the decision: RAISE OR CALL, CALL OR FOLD, FOLD OR CHECK
            and the amount in big blinds to raise or call.
        """
        decision = self.generate_pre_decision(analisys)
        current_call_value = self.get_current_call_value(analisys)
        if current_call_value == '':
            current_call_value = 0
        if decision[0] == 'RAISE OR CALL':
            if current_call_value > decision[1]:
                return {'decision': 'CALL', 'raise_strategy': '0'}
            else:
                return {'decision': 'RAISE', 'raise_strategy': decision[1]}
        if decision[0] == 'CALL OR FOLD':
            if current_call_value > decision[1]:
                return {'decision': 'FOLD', 'raise_strategy': '0'}
            else:
                return {'decision': 'CALL', 'raise_strategy': '0'}
        return {'decision': 'FOLD OR CHECK', 'raise_strategy': '0'}

    def run_strategy(self, analisys):
        """
        This is the main method of the PokerStrategy Class, as it defines what needs to be done, given a
        certain situation (analisys parameter)

        This method implements a very simple decision to be made based on a decision tree using
        the analisys dictionary returned by the PokerTableScanner instance

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: A tuple containing the decision: RAISE OR CALL, CALL OR FOLD, FOLD OR CHECK
            and the amount in big blinds to raise or call.
        """
        if has_command_to_execute(analisys):
            analisys['decision'] = self.generate_decision(analisys)
            analisys['command'] = self.generate_command(analisys)
        return analisys

