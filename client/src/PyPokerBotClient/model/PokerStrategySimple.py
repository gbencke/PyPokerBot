"""
This module contains a very simple strategy class for the PyPokerBot. Strategy classes
are special classes that receives as input the dictionary generated by the PokerTableScanner
class and then generate a decision for that situation and a command that needs to be send
to the Poker Client Software (usually simulating a mouse click).
"""
from PyPokerBotClient.model.PokerStrategy import PokerStrategy
from PyPokerBotClient.model.PokerTableScanner import has_command_to_execute


class PokerStrategySimple(PokerStrategy):
    """
    The PokerStrategySimple Class encapsulates a very simple strategy for the PyPokerBot,
    which is a decision tree based both on the current position of the player on the
    table and its calculated equity (Probabily of having the best hand). There are many
    strategies available and being researched as a field of Computer AI, but this is the
    simplest imaginable.
    """

    def __init__(self):
        """
        Default Constructor, which calls the super class constructor as well...
        """
        PokerStrategy.__init__(self)

    @staticmethod
    def generate_command_fold_or_check(ret, number_of_commands, analisys):
        """
        This method generates a command (which is a index of a button on the poker
        client software), where we need to send a click. It analisys the text of the
        decision and the text of the commands and then return a dictionary with a single
        key: to_execute populated with the index to execute.

        This method is called when the decision is to fold or check.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: a dictionary containing the "to_execute" key filled with the index of the
            command to send
        """
        for current_command in range(number_of_commands):
            if analisys['commands'][current_command][0] == 'CHECK':
                ret['to_execute'] = current_command + 1
                return ret
        for current_command in range(number_of_commands):
            if analisys['commands'][current_command][0] == 'FOLD':
                ret['to_execute'] = current_command + 1
                return ret
        return ret

    @staticmethod
    def generate_command_raise(ret, number_of_commands, analisys):
        """
        This method generates a command (which is a index of a button on the poker
        client software), where we need to send a click. It analisys the text of the
        decision and the text of the commands and then return a dictionary with a single
        key: to_execute populated with the index to execute.

        This method is called when the decision is to raise.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: a dictionary containing the "to_execute" key filled with the index of the
            command to send
        """
        for current_command in range(number_of_commands):
            if analisys['commands'][current_command][0] == 'RAISE' or \
                    analisys['commands'][current_command][0] == 'BET':
                ret['to_execute'] = current_command + 1
                return ret
        for current_command in range(number_of_commands):
            if analisys['commands'][current_command][0] == 'CALL':
                ret['to_execute'] = current_command + 1
                return ret
        for current_command in range(number_of_commands):
            if analisys['commands'][current_command][0] == 'CHECK':
                ret['to_execute'] = current_command + 1
                return ret
        return ret

    @staticmethod
    def generate_command_call(ret, number_of_commands, analisys):
        """
        This method generates a command (which is a index of a button on the poker
        client software), where we need to send a click. It analisys the text of the
        decision and the text of the commands and then return a dictionary with a single
        key: to_execute populated with the index to execute.

        This method is called when the decision is to call.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: a dictionary containing the "to_execute" key filled with the index of the
            command to send
        """
        for current_command in range(number_of_commands):
            if analisys['commands'][current_command][0] == 'CALL':
                ret['to_execute'] = current_command + 1
                return ret
        for current_command in range(number_of_commands):
            if analisys['commands'][current_command][0] == 'CHECK':
                ret['to_execute'] = current_command + 1
                return ret
        return ret

    @staticmethod
    def generate_command(analisys):
        """
        This method generates a command (which is a index of a button on the poker
        client software), where we need to send a click. It analisys the text of the
        decision and the text of the commands and then return a dictionary with a single
        key: to_execute populated with the index to execute.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: a dictionary containing the "to_execute" key filled with the index of the
            command to send
        """
        ret = {'to_execute': 0}

        if not has_command_to_execute(analisys):
            return ret
        number_of_commands = len(analisys['commands'])

        if analisys['decision']['decision'] == 'FOLD OR CHECK':
            return PokerStrategySimple.generate_command_fold_or_check\
                (ret, number_of_commands, analisys)

        if analisys['decision']['decision'] == 'RAISE':
            return PokerStrategySimple.generate_command_raise\
                (ret, number_of_commands, analisys)

        if analisys['decision']['decision'] == 'CALL':
            return PokerStrategySimple.generate_command_call\
                (ret, number_of_commands, analisys)

        return ret

    @staticmethod
    def get_current_call_value(analisys):
        """
        This method returns the current value (money amount) necessary to call anothers
        player bet, as described on the analisys dictionary passed as parameter

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: A number indicating the money amount to call another player.
        """
        call_button = [x for x in analisys['commands'] if x[0] == 'CALL']
        if len(call_button) > 0:
            return call_button[0][1]
        else:
            return 0

    @staticmethod
    def is_check_button_available(analisys):
        """
        Return if the CHECK Button is available on the Poker Client UI.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: True or False
        """
        return len([x for x in analisys['commands'] if x[0] == 'CHECK']) > 0

    @staticmethod
    def position_button(analisys):
        """
        Return if the player is on the button or not.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: True or False
        """
        return analisys['hero']['position'] == 'BUTTON' or analisys['hero']['position'] == 'LP'

    @staticmethod
    def position_out_position(analisys):
        """
        Return if the player is out of position or not.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: True or False
        """
        return not ((analisys['hero']['position'] == 'BUTTON') or
                    (analisys['hero']['position'] == 'LP'))

    def position_bb_check(self, analisys):
        """
        This method checks if the player is on the BigBlind position and the check button is
        available.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: True or False
        """
        return analisys['hero']['position'] == 'BB' and self.is_check_button_available(analisys)

    def position_button_check(self, analisys):
        """
        This method checks if the player is on the button position and the check button is
        available.

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: True or False
        """
        return self.position_button(analisys) and self.is_check_button_available(analisys)

    def generate_pre_decision_preflop(self, hand_equity, analisys):
        """
        This method returns the correct strategy when we are playing the PreFlop

        :param hand_equity: The Mathematical probabilty that our hand is the best
        :param analisys: The Dictionary retuned by PyPokerScanner
        :return: A Tuple containing the decision and the amount to raise
        """

        ret = ('FOLD OR CHECK', 0)
        if self.position_button(analisys):
            if hand_equity > 0.77:
                ret = ('RAISE OR CALL', 20)
            if hand_equity > 0.72:
                ret = ('RAISE OR CALL', 10)
            if hand_equity > 0.60:
                ret = ('RAISE OR CALL', 5)
        if self.position_out_position(analisys):
            if hand_equity > 0.77:
                ret = ('RAISE OR CALL', 20)
            if hand_equity > 0.72:
                ret = ('RAISE OR CALL', 5)
        if self.position_bb_check(analisys):
            if hand_equity > 0.77:
                ret = ('RAISE OR CALL', 20)
            if hand_equity > 0.72:
                ret = ('RAISE OR CALL', 20)
            if hand_equity > 0.60:
                ret = ('RAISE OR CALL', 5)
        return ret

    def generate_pre_decision_flop3(self, hand_equity, analisys):
        """
        This method returns the correct strategy when we are playing the Flop

        :param hand_equity: The Mathematical probabilty that our hand is the best
        :param analisys: The Dictionary retuned by PyPokerScanner
        :return: A Tuple containing the decision and the amount to raise
        """
        ret = ('FOLD OR CHECK', 0)
        if self.position_button(analisys):
            if hand_equity > 0.77:
                ret = ('RAISE OR CALL', 20)
            if hand_equity > 0.72:
                ret = ('RAISE OR CALL', 10)
            if hand_equity > 0.60:
                ret = ('CALL OR FOLD', 5)
        if self.position_button_check(analisys):
            if hand_equity > 0.77:
                ret = ('RAISE OR CALL', 20)
            if hand_equity > 0.72:
                ret = ('RAISE OR CALL', 10)
            if hand_equity > 0.60:
                ret = ('RAISE OR CALL', 5)
        if self.position_out_position(analisys):
            if hand_equity > 0.77:
                ret = ('RAISE OR CALL', 20)
            if hand_equity > 0.72:
                ret = ('RAISE OR CALL', 10)
            if hand_equity > 0.60:
                ret = ('CALL OR FOLD', 5)
        return ret

    def generate_pre_decision_flop4(self, hand_equity, analisys):
        """
        This method returns the correct strategy when we are playing the River

        :param hand_equity: The Mathematical probabilty that our hand is the best
        :param analisys: The Dictionary retuned by PyPokerScanner
        :return: A Tuple containing the decision and the amount to raise
        """
        ret = ('FOLD OR CHECK', 0)
        if self.position_button(analisys):
            if hand_equity > 0.77:
                ret = ('RAISE OR CALL', 40)
            if hand_equity > 0.72:
                ret = ('RAISE OR CALL', 20)
            if hand_equity > 0.60:
                ret = ('CALL OR FOLD', 10)
        if self.position_button_check(analisys):
            if hand_equity > 0.77:
                ret = ('RAISE OR CALL', 40)
            if hand_equity > 0.72:
                ret = ('RAISE OR CALL', 20)
            if hand_equity > 0.60:
                ret = ('RAISE OR CALL', 10)
        if self.position_out_position(analisys):
            if hand_equity > 0.77:
                ret = ('RAISE OR CALL', 40)
            if hand_equity > 0.72:
                ret = ('RAISE OR CALL', 20)
            if hand_equity > 0.60:
                ret = ('CALL OR FOLD', 10)
        return ret

    def generate_pre_decision_flop5(self, hand_equity, analisys):
        """
        This method returns the correct strategy when we are playing the Turn

        :param hand_equity: The Mathematical probabilty that our hand is the best
        :param analisys: The Dictionary retuned by PyPokerScanner
        :return: A Tuple containing the decision and the amount to raise
        """
        ret = ('FOLD OR CHECK', 0)
        if self.position_button(analisys):
            if hand_equity > 0.77:
                ret = ('RAISE OR CALL', 40)
            if hand_equity > 0.72:
                ret = ('RAISE OR CALL', 20)
            if hand_equity > 0.60:
                ret = ('CALL OR FOLD', 10)
        if self.position_button_check(analisys):
            if hand_equity > 0.77:
                ret = ('RAISE OR CALL', 40)
            if hand_equity > 0.72:
                ret = ('RAISE OR CALL', 20)
            if hand_equity > 0.60:
                ret = ('RAISE OR CALL', 10)
        if self.position_out_position(analisys):
            if hand_equity > 0.77:
                ret = ('RAISE OR CALL', 40)
            if hand_equity > 0.72:
                ret = ('RAISE OR CALL', 20)
            if hand_equity > 0.60:
                ret = ('CALL OR FOLD', 10)
        return ret

    def generate_pre_decision(self, analisys):
        """
        This method implements a very simple decision to be made based on a decision tree using
        the analisys dictionary returned by the PokerTableScanner instance

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: A tuple containing the decision: RAISE OR CALL, CALL OR FOLD, FOLD OR CHECK
            and the amount in big blinds to raise or call.
        """
        try:
            phase = analisys['hand_analisys']['hand_phase']
            hand_equity = analisys['hand_analisys']['result'][0][1]

            if phase == 'PREFLOP':
                return self.generate_pre_decision_preflop(hand_equity, analisys)
            if phase == 'FLOP3':
                return self.generate_pre_decision_flop3(hand_equity, analisys)
            if phase == 'FLOP4':
                return self.generate_pre_decision_flop4(hand_equity, analisys)
            if phase == 'FLOP5':
                return self.generate_pre_decision_flop5(hand_equity, analisys)
        except:
            pass
        return ('FOLD OR CHECK', 0)

    def generate_decision(self, analisys):
        """
        This method implements a very simple decision to be made based on a decision tree using
        the analisys dictionary returned by the PokerTableScanner instance

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: A tuple containing the decision: RAISE OR CALL, CALL OR FOLD, FOLD OR CHECK
            and the amount in big blinds to raise or call.
        """
        decision = self.generate_pre_decision(analisys)
        current_call_value = self.get_current_call_value(analisys)
        if current_call_value == '':
            current_call_value = 0
        if decision[0] == 'RAISE OR CALL':
            if current_call_value > decision[1]:
                return {'decision': 'CALL', 'raise_strategy': '0'}
            else:
                return {'decision': 'RAISE', 'raise_strategy': decision[1]}
        if decision[0] == 'CALL OR FOLD':
            if current_call_value > decision[1]:
                return {'decision': 'FOLD', 'raise_strategy': '0'}
            else:
                return {'decision': 'CALL', 'raise_strategy': '0'}
        return {'decision': 'FOLD OR CHECK', 'raise_strategy': '0'}

    def run_strategy(self, analisys):
        """
        This is the main method of the PokerStrategy Class, as it defines what
        needs to be done, given a certain situation (analisys parameter)

        This method implements a very simple decision to be made based on a decision tree using
        the analisys dictionary returned by the PokerTableScanner instance

        :param analisys: The analisys dictionary returned by a PokerTableScanner instance
        :return: A tuple containing the decision: RAISE OR CALL, CALL OR FOLD, FOLD OR CHECK
            and the amount in big blinds to raise or call.
        """
        if has_command_to_execute(analisys):
            analisys['decision'] = self.generate_decision(analisys)
            analisys['command'] = self.generate_command(analisys)
        return analisys
